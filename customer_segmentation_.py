# -*- coding: utf-8 -*-
"""Customer Segmentation .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rInJFSOQzTGS3kO5TzpehzTxOQc6t_7R

**Importing the libraries**
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
import seaborn as sns

"""**Loading the data**"""

#importing the data into the notebook
mall_customer_data = pd.read_csv("/content/Mall_Customers.csv")

"""**Knowing the data**"""

#viewing thefirst 5 rows from the dataset
mall_customer_data.head()

#finding the number of rows and columns of the dataset
mall_customer_data.shape

"""*There are 200 rows that i.e details about 200 customers and 5 columns in the dataset*"""

#getting info regarding the datatype about the data
mall_customer_data.info()

#finding if there are any missing values in the dataset
mall_customer_data.isnull().sum()

"""*There are no null values in the dataset*

**Removing the unwanted columns**
"""

#from the dataset last 2 columns are only the necessary ones
#Making a new dataset X having the last 2 columns from the mall_customer_data dataset

X= mall_customer_data.iloc[:,[3,4]].values
print(X)

"""**Finding the number of clusters that are going to be formed**

Here we use WCSS(within cluster sum of square) method
"""

# using the loop

wcss =[]

for i in range (1,11):
  kmeans = KMeans(n_clusters =i , init="k-means++" , random_state = 1)
  kmeans.fit(X)

  wcss.append(kmeans.inertia_)

"""Plotting an elbow curve to find the number of clusters"""

sns.set()

plt.plot(range(1,11),wcss)
plt.title("The Elbow Point Graph")
plt.xlabel("The number of clusters")
plt.ylabel("WCSS")
plt.show()

"""The curve is breaked at point 3 and 5. We will consider the later break, i.e. 5.
Therefore, the whole dataset is divided into 5 clusters.

**Training the K-Means model**
"""

kmeans =KMeans(n_clusters = 5,init = "k-means++" , random_state=1)

#return a label for each data point based on their cluster
Y = kmeans.fit_predict(X)
print(Y)

"""**Visualizing the clusters**"""

#plotting the clusters

plt.scatter(X[Y==0,0],X[Y==0,1],s= 50, c="blue", label="Cluster 1")
plt.scatter(X[Y==1,0],X[Y==1,1],s= 50, c="green", label="Cluster 2")
plt.scatter(X[Y==2,0],X[Y==2,1],s= 50, c="yellow", label="Cluster 3")
plt.scatter(X[Y==3,0],X[Y==3,1],s= 50, c="orange", label="Cluster 4")
plt.scatter(X[Y==4,0],X[Y==4,1],s= 50, c="red", label="Cluster 5")

#plotting the centroids for each cluster
plt.scatter(kmeans.cluster_centers_[:,0],kmeans.cluster_centers_[:,1], s=100, c="black",
            label ="Centroids")

plt.title("Customer Groups")
plt.xlabel("Annual Income of Customers")
plt.ylabel("Spending Score of Customers")

"""**Insights**

**Cluster 1 (represented by color blue):**
The customers of this cluster tend to spend more while shopping even though they their annual income is less compared to other customers.

**Cluster 2 (represented by color green):** The customers of this cluster tend to spend less while shopping even though they their annual income is more compared to other customers.

**Cluster 3 (represented by color yellow):** The customers of this cluster tend to spend average amount of money, not too high not too low while shopping. Also their annual income is average, which means they shop equivalent to their income.

**Cluster 4 (represented by color orange):** The customers of this cluster tend to spend more while shopping, also their annual income is more compared to other customers and can be equivalent to customers of cluster 2.

**Cluster 5 (represented by color red):** The customers of this cluster tend to spend less while shopping, also their annual income is less compared to other customers and can be equivalent to customers of cluster 1.
"""